---
title: "final project.rmd"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(rtracklayer)
library(AnnotationHub)
library(SummarizedExperiment)
ah <- AnnotationHub()

#a bunch of different proteins
#look at available chipseq data 
pax5.experiments <- query(ah, c("PAX5", "Tfbs", "UniPk"))
rest.experiments <- query(ah, c("REST", "Tfbs", "UniPk"))
usf1.experiments <- query(ah, c("USF1", "Tfbs", "UniPk"))
max.experiments <- query(ah, c("MAX", "Tfbs", "UniPk"))
jund.experiments <- query(ah, c("JUND", "Tfbs", "UniPk"))
yy1.experiments <- query(ah, c("YY1", "Tfbs", "UniPk"))
gabpa.experiments <- query(ah, c("GABPA", "Tfbs", "UniPk"))

#pulls summarized experiment for cell line a protein
#most complete options are JUND, MAX, USF1, in H1hesc, Hepg2, GM12878, K562
get.exp <- function(cell.line, protein){
  
  cell.protein.query <- query(ah, c(cell.line, protein, "Tfbs", "UniPk"))
  if (length(cell.protein.query) == 0){
    
    print(paste("No matches for", paste(cell.line, protein)))
    
  }
  if( length(cell.protein.query) > 0){
    
    query(ah, c(cell.line, protein,"Tfbs", "UniPk"))[[1]]
    
  }
}

library("BSgenome.Hsapiens.UCSC.hg19")

#function to extract dna stringset from 
extract.seq <- function(exp.data, subset = TRUE){
  
  if (subset){
    
    #make widths of sequence the same 
    #per paper, use 100 bp
  
    #first subset out small peaks 
    target.peaks <- exp.data[width(exp.data) > 100, ]
  
    #get the middle of ranges with more than 100 peaks 
    exp.data <- target.peaks - round((width(target.peaks) - 100)/2)
    exp.data <- resize(exp.data, 100)
    
  }
  
  #extract sequences 
  seqs <- getSeq(Hsapiens, exp.data)
  return(seqs)
  
}


#function to pull down data for a single cell line and protein
#and put it together into a useable dnastring set and vector 
#of binding site vs non-binding predictions 
format.exp.data <- function(protein, cell.line){
  
     #pull down data for protein and cell line 
    exp.data <- get.exp(protein, cell.line)
    
    #subset to top 1000 of 100 bp per paper instructions 
    top.peaks <- exp.data[width(exp.data) > 100, ]
    top.peaks <- top.peaks[order(-top.peaks$signalValue), ]
    top.peaks <- top.peaks[1:1000, ]
    
    #get 100 bp flanking regions sampled 200 bp away
    flank.regions <- flank(top.peaks + 200, 100)
    
    #extract sequence for target peaks and flanks 
    binding.seqs <- extract.seq(top.peaks)
    non.binding.seqs <- extract.seq(flank.regions, subset = F)
    
    #concatenate 
    combined.seqs <- c(binding.seqs, non.binding.seqs)
    
    #make vector of binding site classification 
    #1 for tf binding, -1 for non-binding 
    tf.binding <- c(rep(1, length(binding.seqs)), rep(-1, length(non.binding.seqs)))
  
    #return string set and tf.binding vector 
    return(list(sequences = combined.seqs, tf.binding = tf.binding))
  
}

#specify target proteins and cells 
target.proteins <- rep(c("JUND", "MAX", "USF1"), each = 4)
target.cells <- rep(c("H1HESC", "HEPG2", "GM12878", "K562"), 3)

#pull in data 
library(BiocParallel)
param <- bpparam()
bpworkers(param) <- 5
exp.data.list <- bpmapply(format.exp.data, target.proteins, target.cells, BPPARAM = param, SIMPLIFY = F)

#name the elements of the list 
names(exp.data.list) <- paste(target.proteins, target.cells)

#make another list by combining protein data across cell types 
combined.cell.data.list <- lapply(unique(target.proteins), function(protein){
  
  protein.cell.data <- exp.data.list[grep(protein, names(exp.data.list))]
  combined.cell.data <- Reduce(function(...) mapply(c, ...), protein.cell.data)
  return(combined.cell.data)
  
})
names(combined.cell.data.list) <- unique(target.proteins)

#function to run svm and get information on binding site prediction 
run.svm <- function(combined.seqs, tf.binding){
  
  #set kernel 
  #this is not the precise kernel used in the paper 
  #but seems similar, is avaialable in this package, and is from the same
  #author of the paper 
  
  #note: using k = 8 and and m = 2 per paper 
  mismatch.kern <- mismatchKernel(k=8,m=2)
  
  #get training and test data 
  n.samples <- length(tf.binding)
  training.obs <-sample(1:n.samples, 0.7*n.samples)
  test.obs <-c(1:n.samples)[-training.obs]
  
  #run svm on test data 
  exrep<-getExRep(combined.seqs, mismatch.kern, sparse=FALSE)
  svm.model <- kbsvm(x = exrep[training.obs, ], y = tf.binding[training.obs], kernel = mismatch.kern)
  
  #look at accuracy 
  pred.profile <- predict(svm.model, combined.seqs[test.obs], predProfiles = T)
  svm.predictions <- predict( svm.model, exrep[test.obs, ])
  svm.decisions <- predict(svm.model, exrep[test.obs, ], predictionType = "decision")
  eval.data <- evaluatePrediction( svm.predictions, tf.binding[test.obs], allLabels = unique(tf.binding), decValues = svm.decisions, print = F)
  
  #get auc
  rocdata<-computeROCandAUC(svm.decisions, tf.binding[test.obs], unique(tf.binding))
  return(list(rocdata = rocdata, pred.profile = pred.profile, eval.data = eval.data))
  
}

#run svm
library(kebabs)

#first on cell specific data
svm.indiv.cell <- bplapply(exp.data.list, function(cell.protein.data){
  
    run.svm(cell.protein.data$sequences, cell.protein.data$tf.binding)
  
}, BPPARAM = param)
names(svm.indiv.cell) <- names(exp.data.list)

#then on protein data combined across cell types 
svm.combined.cell <- bplapply(combined.cell.data.list, function(comb.cell.data){
  
    run.svm(comb.cell.data$sequences, comb.cell.data$tf.binding)
  
}, BPPARAM = param)

names(svm.combined.cell) <- names(combined.cell.data.list)

#plot ROC curves for each 
graphics.off()
par("mar")
par(mar=c(1,1,1,1))
par(mfrow = c(6,2))
lapply(names(svm.indiv.cell), function(protein.cell){
  
  #plotting options 
  
  plot.data <- svm.indiv.cell[[protein.cell]]
  plot(plot.data$rocdata, main = protein.cell ,col="red",lwd=2)
  
})
```

```{r}
#also for combined cell results 
graphics.off()
par("mar")
par(mar=c(1,1,1,1))
par(mfrow = c(3,1))
lapply(names(svm.combined.cell), function(protein){
  
  plot.data <- svm.combined.cell[[protein]]
  plot(plot.data$rocdata, main = protein ,col="red",lwd=2)
  
})


#plotting options 
plot(rocdata,main="Receiver Operating Characteristics",col="red",lwd=2)

plot(pred.profile$predictionProfiles,sel=1,ylim=c(-0.05,0.05))

```
```{r}

#pull in open chromatin data 

gm12878.dnase <- query(ah, c("GM12878", "dnase", "UniPk"))[[1]]
h1hesc.dnase <- query(ah, c("H1HESC", "dnase", "UniPk"))[[1]]
hepg2.dnase <- query(ah, c("HEPG2", "dnase", "UniPk"))[[1]]
k562.dnase <- query(ah, c("k562", "dnase", "UniPk"))[[1]]


```
